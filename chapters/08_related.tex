\chapter{Related Work}
\label{ch:related}

\section{Memory Safety for WebAssembly}
\label{sec:related-memory-safety-for-webassembly}

This thesis builds upon existing efforts in the field of memory safety for \ac{WASM}.
Here, we examine notable projects aiming to achieve similar goals and highlight the distinct contributions of our research.

\subsection{MS-WASM}
\label{subsec:ms-wasm}

A significant project in this domain is MS-WASM, a memory safety extension for WASM introduced by \citeauthor*{disselkoen2019position} and further developed by \citeauthor*{michael2023mswasm}~\cite{disselkoen2019position,michael2023mswasm}.
MS-WASM introduces a new \textit{segment memory} distinct from the linear memory, preventing accesses through arbitrary offsets.
The segment memory relies on access through unforgeable \textit{handles}, akin to CHERI pointers~\cite{woodruff2014cheri}.

\paragraph{Key Differences}
This thesis adopts a different approach by enabling a gradual migration of memory segments into the linear memory.
This preserves compatibility with unmodified code, as only the allocation of allocation has to be changed.
Memory accesses are still performed through integers, not pointers.
We do not implement intra-memory safety to allow implementation with \ac{MTE}, which uses colors for memory access control rather than the shading required for intra-object safety.
Utilizing \ac{MTE} allows our implementation to run with significantly lower overhead on devices supporting this technology.

\subsection{RichWasm}
\label{subsec:richwasm}

RichWasm is a richly-typed intermediate language designed to facilitate safe memory interactions between languages with diverse memory management models (e.g., manual and garbage-collected)~\cite{paraskevopoulou2024richwasm}.
It enables static detection of potential memory safety violations, making it particularly valuable for mixed-language interoperability.

RichWasm is intended for use as a compilation target for safe languages like Rust or OCaml, which have strong memory safety guarantees encoded in their type systems.
Languages like C, which lack information for static type safety analysis, are not directly supported by RichWasm's type-driven safety model.

\subsection{Pointer Authentication}
\label{subsec:related-pointer-authentication}

\citeauthor*{rehde2023wasm} has worked on implementing pointer authentication primitives~\cite{rehde2023wasm}.
In their work, they add pointer authentication primitives backed by ARM's \ac{PAC} to the memory safety extension described in this thesis.
This complements our work by providing additional protection mechanisms against pointer corruption.

\section{MTE for Memory Safety}
\label{sec:mte-for-memory-safety}

A few memory allocators have implemented support for MTE, including:

\begin{itemize}
    \item Scudo Hardened Allocator (used in Android): A security-oriented allocator providing defense mechanisms against heap-based vulnerabilities\footnote{\url{https://llvm.org/docs/ScudoHardenedAllocator.html}}.
    \item Chrome's PartitionAlloc: A partitioning allocator focusing on security and efficiency for multithreaded environments\footnote{\url{https://chromium.googlesource.com/chromium/src/+/master/base/allocator/partition_allocator/}}
    \item glibc's Ptmalloc: The GNU C library's standard memory allocator, with evolving experimental support for MTE\footnote{\url{https://ftp.gnu.org/gnu/glibc/}}.
\end{itemize}

\section{Memory Safety}
\label{sec:related-memory-safety}

Additionally, an overview of other important projects contributing to memory safety:

\subsection{ASAN}
\label{subsec:related-asan}

\ac{ASAN} is a compiler instrumentation tool that dynamically detects memory safety errors at runtime~\cite{serebryany2012addresssanitizer}.
It employs techniques like shadow memory to track memory states and flag heap and stack overflows, use-after-free errors, use-after-return errors, and other memory related issues.

\ac{ASAN} is widely used in development and testing environments due to its effectiveness, but is usually not deployed in production due to its runtime overhead.

\subsection{GWP-ASan}
\label{subsec:gwp-asan}

GWP-ASan adopts a probabilistic approach to memory safety~\cite{serebryany2023gwp}.
It samples a subset of allocations and places them in a guarded memory region to detect spatial and temporal memory safety violations for those allocations.

The low selection probability means GWP-ASAN has minimal runtime overhead, making it suitable for large-scale production deployments.
Its goal is to identify hard-to-reproduce memory bugs triggered by real-world user behavior and not covered by fuzzing or tests.
